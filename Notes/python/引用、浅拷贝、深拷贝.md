#引用、浅拷贝与深拷贝
[TOC]
## 按值赋值VS按引用赋值
变量赋值有两种方式：按值赋值或者按引用（指针）赋值，不同的编程语言赋值的方式不一样，python是按指针传递，Go是按值传递。

- 按值赋值
	每次次赋值的时候都拷贝内存中完整的数据结构对象，相当于另外开辟一个空间，这时在内存中有两个相同的数据结构对象，但所在地址不同。
- 按引用赋值
	每次赋值的时候只拷贝内存中数据结构对象的地址，这个地址占用一个机器字节，有些数据对象除了指针还有其他属性，这时可能会占用数个机器字长。相当于将原先数据对象的地址赋给该变量。这种方式只能拷贝数据对象的属性（内存地址）。拷贝内容很少，速度非常快，但拷贝完之后，内存中仍然只有一份数据对象，但会存在两份完全相同指向内存中同一数据对象的指针，不管通过哪个指针去改变对象，都会影响另一个
- 总结
	对于不支持指针的编程语言，通常将按指针的传递成为浅拷贝（shadow copy），并会提供另一个函数或方法来实现值传递，称之为深拷贝（deep copy）


## 可变数据对象和不可变数据对象

- 不可变数据对象
	当该数据类型的对应变量的值发生改变之后，其对应的内存地址也会放生改变。

- 可变数据对象
	当该数据类型对的应变量的值发生改变之后，其对应的内存地址不发生改变。
    
- Python中的可变和不可变数据类型
1. 不可变

	整型int、布尔型boolean，字符串string、浮点数float，日期date和元组tuple。不可变数据类型不允许变量的值发生变化，如果改变了变量的值，相当于新建了一个独享，对于相同的值的对象，内存总只有一个对象，内部会有一个引用计数来记录有多少变量引用该对象

2. 可变

	列表list，字典dict。可变数据类型允许变量的值发生变化，对变量进行append和+=之类的操作，只是改变了变量的值，不会新建一个对象，所以变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中会存在不同的对象，每个对象有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是真实存在的对象

3. 小数池

	Python中为了减少开辟内存导致的时间开销，对于三位内整形数字类型数据，在开辟一块内存空间后，后面的三位内的整型数据都放到这个内存空间中，所以三位以内的整型数字类型的ID值都是相同的

## 引用（直接赋值）、浅拷贝与深拷贝

- Python中所有都是引用，‘万物皆引用’，参数的传递，变量的赋值默认均为引用。引用实际上传递的是地址。

	对于不可变的数据对象，在引用的时候，是将被引用数据对象的地址传递给引用对象，但是在后期对这两个变量进行操作的时候，由于对不可变数据对象的操作，都是在内存中另外创建一个空间来放置更改后的数据对象，但另一个数据对象引用的仍是原有的不可变数据对象的地址，所以两者不会影响。当系统发现不可变数据对象的被引用次数变为0,则会让垃圾回收机制将其回收。
    但对于可变数据对象而言，引用传递的是数据对象的总地址，而非该数据对象内的不可变数据的真实地址，所以后期操作的时候，两个数据对象的操作会影响对方。

- 浅拷贝

	浅拷贝指的是将变量的第一层浅层地址传递过去，如果list，dict中含有复合的数据对象，那么浅拷贝传递过去的仍旧是该数据对象的地址，对该数据对象做的任何操作，将会在原有的和浅拷贝得来的两个数据对象中同时发生改变。

- 深拷贝

	深拷贝指的是将所有数据的值传递给引用对象，实现了完全意义上的数据分离，之后所做的任何操作，互不相关。实现方法为copy模块中的deepcopy()方法

一般而言，浅拷贝或者引用赋值满足了我们期待的操作，只有涉及到少数时候（数据序列化，需要传输或者持久化的时候）才会需要深拷贝操作，即使是这样，也只需要调用内置模块的函数即可。

## python中的垃圾回收机制

Python的垃圾回收机制是以引用计数为主，分代回收为辅。这里简单介绍一下引用计数的垃圾回收。引用计数回收的方法会因循环引用而导致出现内存泄漏。
理论上讲，Python中的每个对象都会有对应的引用计数，可以通过sys.getrefcount()来查看对象的引用计数(但实际上打印出的数字会比实际多1,因为方法本身也对对象进行了一次引用)，当引用计数归0的时候，系统会将其回收。

引用计数+1的情况：
- 对象被创建 a=1
- 对象被引用 a=b
- 作为参数传递到一个函数中去 func(a)
- 对象被作为一个元素储存在容器中 list=[a,a]

引用计数-1的情况：
- 对象的别名被显式销毁 del a
- 对象的别名被赋于新的对象 a=2
- 对象离开其作用域 函数中的局部变量（全局变量不会）
- 对象所在的容器被销毁，或者被从容器中删除 list.remove  del list

循环调用导致内存泄漏：
```python
	def f2():
    	while True:
        	c1=ClassA()
        	c2=ClassA()
        	c1.t=c2
        	c2.t=c1
        	del c1
        	del c2

```
调用f2()会导致进程占用的内存不断变大，导致内存泄漏。
创建对象时，c1和c2引用次数都为1,经过两次引用，引用次数均为2,显式删除后其引用次数仍为1,所以垃圾回收器不会回收，导致内存泄漏。

垃圾回收机制Garbage Collector interface：
gc模块是python提供给开发者设置回收垃圾的选项。

常用方法函数：
- gc.set_debug(flags) 设置gc的debug日志，一般设置为gc.DEBUG_LEAK
- gc.collect([generation]) 显式进行垃圾回收，可以输入参数0代表第一代，1代表第一第二代，2代表第一第二第三代，默认为2,进行full collection
- gc.set_threshold() 设置自动回收垃圾的频率
- gc.count() 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表

gc的自动回收垃圾机制，需要import gc，并将is_enable()=True才会启动自动垃圾回收，该机制的作用是主动发现并处理不可达的垃圾对象。

所以尽量避免循环调用，引入gc模块，启动gc模块的自动垃圾回收机制。详细内容请移步python的内存管理机制查看。


##Rerference
1.https://www.cnblogs.com/f-ck-need-u/p/10123145.html
2.https://www.cnblogs.com/f-ck-need-u/p/9928418.html
3.https://www.cnblogs.com/Xjng/p/5128269.html